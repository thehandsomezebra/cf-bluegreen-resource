#!/bin/bash

set -e -u

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source=$1
if [[ -z "$source" ]]; then
  echo "usage: $0 <path/to/source>"
  exit 1
fi
# for jq
PATH=/usr/local/bin:$PATH
export TMPDIR=${TMPDIR:-/tmp/bluegreen}
mkdir -p "${TMPDIR}"
payload=$(mktemp "$TMPDIR/resource-request.XXXXXX")
cat > "$payload" <&0

#from the task
org=$(jq -r '.params.org // ""' < "$payload")
space=$(jq -r '.params.space // ""' < "$payload")
current_app_name=$(jq -r '.params.current_app_name // ""' < "$payload")
manifest=$(jq -r '.params.manifest // ""' < "$payload")
path=$(jq -r '.params.path // ""' < "$payload")
show_app_log=
no_start=$(jq -r '.params.no_start // ""' < "$payload")

#from the resource
api=$(jq -r '.source.api // ""' < "$payload")
username=$(jq -r '.source.username // ""' < "$payload")
password=$(jq -r '.source.password // ""' < "$payload")

skip_cert_check=$(jq -r '.source.skip_cert_check // ""' < "$payload")
if [$skip_cert_check==true]
    then
    skipssl=" --skip-ssl-validation"
    else
    skipssl=""
fi

## to test in the hijacked container:
    #.source. is from resource  
    #.params. is from task

## cd /tmp/bluegreen | ls
##cat resource-request.RANDOMWHATEVER | jq -r '.source.username // ""'

echo "setting api"  >&2
cf api "$api"
echo "success" >&2

echo "logging in"  >&2
cf login -u "$username" -p "$password" "$skipssl"
echo "success" >&2

echo "setting target"  >&2
cf target -o $org -s $space
echo "success" >&2

##check that the app passed in legit
if [cf app $current_app_name 2>&1 ==1]
    echo "App $current_app_name does not exist" >&2
    exit 1
fi

## rename current_app_name to blue
blue_app_name="$current_app_name-blue"
cf rename "$current_app_name" "$blue_app_name"




##set up variable for the new app name
green_app_name="$current_app_name-green"







# # . Generate random route
# # ** Need to write something for this, remembering the domain name cannot be more than 63 characters

###############
    ##get the domain from the input
#domain=$(get_option '.domain')
original_route=$(cf app $current_app_name | grep routes | awk '{print $2}')
original_domain=$(echo $original_route | sed -e "s/$current_app_name.//g")
 #hostname=$(get_option '.hostname')
    ## new route will be $green_app_name.$original_domain
###############
# begin setting up args for new route

cf create-route $space $original_domain --hostname $green_app_name

#route now exists as:
green_route_path=$green_app_name.$original_domain



cf push $green_app_name -f $manifest -p $path --route-path "$green_route_path"

#if show_app_log then cf logs "$app_name" --recent
#cf logs "$green_app_name" --recent

# . Push green app with random route 
##cf push sets domain as default apps.internal, subdomain.example.com
## https://cli.cloudfoundry.org/en-US/v6/push.html



#https://cli.cloudfoundry.org/en-US/v6/push.html
#include the new random route in this push 


#execute smoke tests, if any
# . For each smoke test
# .. Execute passing in the random route as the first input (`$1`)
# .. Capture the result
# *** If `exit_code` is 0, continue
# *** Else
# **** If `clean_up` is `true`
# ***** Delete green
# ***** Rename blue by removing suffix `-blue`
# **** `exit 1`



#if success from smoke test (or no smoke tests offered)

# . Map route(s) from incoming manifest to green
cf map-route $green_app_name $original_domain -n $current_app_name


# . Unmap route to blue
cf unmap-route $blue_app_name $original_domain -n $current_app_name

# . Unmap temporary route from green
cf unmap-route $green_app_name $original_domain -n $green_app_name


# . Rename green app to the original app name
cf rename $green_app_name $current_app_name


##IF CLEANUP IS TRUE

# . Delete blue
#cf delete $blue_app_name

# OR rename it, so it can be looked at later,
#cf rename $blue_app_name $current_app_name-old
















##done
jq -n \
--arg timestamp $(date +%s) \
'{
  version: {
    timestamp: $timestamp
  }
}' >&3