#!/bin/bash

set -e -u

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging


BRed='\033[1;31m'  #Bold red
BGreen='\033[1;32m'       # Bold Green
BBlue='\033[1;34m'        # Bold Blue
NC='\033[0m' # No Color


source=$1
if [[ -z "$source" ]]; then
  echo "usage: $0 <path/to/source>"
  exit 1
fi
# for jq
PATH=/usr/local/bin:$PATH
export TMPDIR=${TMPDIR:-/tmp/bluegreen}
mkdir -p "${TMPDIR}"
payload=$(mktemp "$TMPDIR/resource-request.XXXXXX")
cat >"$payload" <&0

#from the task
org=$(jq -r '.params.org // ""' <"$payload")                           #required
space=$(jq -r '.params.space // ""' <"$payload")                       #required
current_app_name=$(jq -r '.params.current_app_name // ""' <"$payload") #required

path_file=$(jq -r '.params.path // ""' <"$payload") #optional
if [ -z ${path_file+x} ]; then
  path=
else
  path=/tmp/build/put/$path_file
fi

manifest_file_location=$(jq -r '.params.manifest // ""' <"$payload") #required
manifest=/tmp/build/put/$manifest_file_location
###

##############################################################
#get and set manifest variables
manifest_env_variables_json=$(jq -r '.params.manifest_env_variables // ""' <"$payload")
if [[ ! -z ${manifest_env_variables_json+x} ]]; then #append these variables to the manifest yml file under env:

  get_keys() {
    echo "$manifest_env_variables_json" | jq -r 'keys[]'
  }

  get_value() {
    local key=${1:?key null or not set}
    echo "$manifest_env_variables_json" | jq -r --arg key "$key" '.[$key]'
  }

  has_app_name() {
    [ -n "$current_app_name" ] && [ -n "$(yq read "$manifest" "applications.name==$current_app_name")" ]
  }

  has_one_app() {
    [ "1" == "$(yq read "$manifest" "applications" -l)" ]
  }

  for key in $(get_keys); do
    if has_app_name; then
      yq write -i "$manifest" -- "applications(name==$current_app_name).env.$key" "$(get_value "$key")"
    elif has_one_app; then
      yq write -i "$manifest" -- "applications[0].env.$key" "$(get_value "$key")"
    else
      yq write -i "$manifest" -- "env.$key" "$(get_value "$key")"
    fi
  done

fi

##############################################################

smoketest_file=$(jq -r '.params.smoketest // ""' <"$payload") #optional
if [[ ! -z ${smoketest_file+x} ]]; then

  smoketest=/tmp/build/put/$smoketest_file  >&2
  ## load in params, if any
  smoketest_vars_json=$(jq -r '.params.smoketest_variables // ""' <"$payload")
  if [[ ! -z ${smoketest_vars_json+x} ]]; then #set all those as variables here
    smoketest_vars=$( echo $smoketest_vars_json | jq -r ' to_entries |  .[] | .key + "=\"" + .value + "\""')
    for key in ${smoketest_vars}; do
      eval ${key} >&2
    done
  fi
fi

no_start=$(jq -r '.params.no_start // ""' <"$payload") #optional
if [[ -n "$no_start" ]] && [[ $no_start==true ]]; then
  no_start_option=" --no-start"
else
  no_start_option=""
fi

keep_old_app=$(jq -r '.params.keep_old_app // ""' <"$payload") #optional

#from the resource
api=$(jq -r '.source.api // ""' <"$payload")
username=$(jq -r '.source.username // ""' <"$payload")
password=$(jq -r '.source.password // ""' <"$payload")

skip_cert_check=$(jq -r '.source.skip_cert_check // ""' <"$payload")
if [[ -n "$skip_cert_check" ]] && [[ $skip_cert_check==true ]]; then
  skipssl=" --skip-ssl-validation"
else
  skipssl=""
fi

## to test in the hijacked container:
#.source. is from resource
#.params. is from task

## cd /tmp/bluegreen | ls
## cat resource-request.RANDOMWHATEVER | jq -r '.[]'
## cat resource-request.RANDOMWHATEVER | jq -r '.source.username // ""'

printf "${BBlue}logging in${NC}\n"   >&2
cf login -a "$api" -u "$username" -p "$password" $skipssl
printf "${BGreen}Successful.${NC}\n"   >&2

printf "${BBlue}setting target${NC}\n"   >&2
cf target -o $org -s $space
printf "${BGreen}Successful.${NC}\n"   >&2




##check that the app passed in legit
if [[ `cf apps | grep $current_app_name` ]]; then 
printf "${BBlue}$current_app_name found. Proceeding with Blue Green Deployment${NC}\n"   >&2
 else
  printf "${BRed}$current_app_name not found. Exiting.${NC}\n"   >&2
  exit 1
   fi


## rename current_app_name to blue
blue_app_name="blue-$current_app_name"
printf "${BBlue}Renaming $current_app_name to $blue_app_name ${NC}\n"   >&2
cf rename "$current_app_name" "$blue_app_name"
printf "${BGreen}Successful.${NC}\n"   >&2

##set up a few variables
green_app_name="green-$current_app_name"
original_route=$(cf app $blue_app_name | grep routes | awk '{print $2}')
original_hostname="$(cut -d '.' -f 1 <<<"$original_route")"
original_domain="$(cut -d '.' -f 2- <<<"$original_route")"

#new temporary green hosthame:
green_hostname=green-$original_hostname

#new temporary route:
green_route_path=$green_hostname.$original_domain

printf "${BBlue}Creating new temporary route of $green_route_path...${NC}\n"   >&2
cf create-route $space $original_domain --hostname $green_hostname
printf "${BGreen}Successful.${NC}\n"   >&2

printf "${BBlue}Pushing new green app $green_app_name with no route.${NC}\n"   >&2
cf push $green_app_name -f $manifest -p $path --no-route $no_start_option
printf "${BGreen}Successful.${NC}\n"   >&2

#map green app to green route
printf "${BBlue}Mapping green app $green_app_name to $green_route_path${NC}\n"   >&2
cf map-route $green_app_name $original_domain -n $green_hostname
printf "${BGreen}Successful.${NC}\n"   >&2

######################################SMOKE TEST######################################

if [ -z ${smoketest+x} ]; then
  printf "${BBlue}Smoketesting skipped.${NC}\n"   >&2
else
  printf "${BBlue}Beginning smoketest: full location: $smoketest  file: $smoketest_file${NC}\n"   >&2

  #setting smoketest url for green app
  SMOKETEST_URL="https://$green_hostname.$original_domain"

  chmod +x $smoketest        #set the script to executable
  TEST=$(source $smoketest )         #runs the test
  STATUS=$?                  #gets the exit code/last executed cmd from the test
  if [ $STATUS -eq 0 ]; then # report back on smoketest
    echo "Smoketest successfully passed!" >&2
  else
    echo "Smoketest failed." >&2
    echo "Running cleanup..." >&2
    # . Rename blue app to the original app name
    printf "${BBlue}Renaming blue app to the original app name${NC}\n"   >&2
    cf rename $blue_app_name $current_app_name
    printf "${BGreen}Successful.${NC}\n"   >&2

    # . delete the unused green route
    printf "${BBlue}Delete green route${NC}\n"   >&2
    cf delete-route $original_domain -n $green_hostname -f
    printf "${BGreen}Successful.${NC}\n"   >&2

    #. Delete green
    printf "${BBlue}Deleting app $green_app_name${NC}\n"   >&2
    cf delete $green_app_name -f
    printf "${BGreen}Successful.${NC}\n"   >&2

    exit 1
  fi

fi

######################################################################################

# . Map route from incoming manifest to green
printf "${BBlue}Mapping original route to green app${NC}\n"   >&2
cf map-route $green_app_name $original_domain -n $original_hostname
printf "${BGreen}Successful.${NC}\n"   >&2

# . Unmap route to blue
printf "${BBlue}Unmapping route to blue${NC}\n"   >&2
cf unmap-route $blue_app_name $original_domain -n $original_hostname
printf "${BGreen}Successful.${NC}\n"   >&2

# . Unmap temporary route to green
printf "${BBlue}Unmapping temporary route to green${NC}\n"   >&2
cf unmap-route $green_app_name $original_domain -n $green_hostname
printf "${BGreen}Successful.${NC}\n"   >&2

# . delete the unused green route
printf "${BBlue}Delete unused green route${NC}\n"   >&2
cf delete-route $original_domain -n $green_hostname -f
printf "${BGreen}Successful.${NC}\n"   >&2

# . Rename green app to the original app name
printf "${BBlue}Renaming green app to the original app name${NC}\n"   >&2
cf rename $green_app_name $current_app_name
printf "${BGreen}Successful.${NC}\n"   >&2

printf "${BBlue}Deleting green route${NC}\n"   >&2
cf delete-route $original_domain -n $green_hostname -f
printf "${BGreen}Successful.${NC}\n"   >&2

#######If keep old app is true...

if [[ -n "$keep_old_app" ]] && [[ $keep_old_app==true ]]; then
  #delete blue
  printf "${BBlue}Deleting app $blue_app_name${NC}\n"   >&2
  cf delete $blue_app_name -f
  printf "${BGreen}Successful.${NC}\n"   >&2
else
  #rename blue
  printf "${BBlue}Renaming app $blue_app_name to $current_app_name-old${NC}\n"   >&2
  if [[ `cf apps | grep $current_app_name-old` ]]; then 
printf "${BBlue}Previous old app being removed...${NC}\n"   >&2
 cf delete $current_app_name-old -f
   fi
  cf rename $blue_app_name $current_app_name-old
  printf "${BGreen}Successful.${NC}\n"   >&2
fi

##done
jq -n \
  --arg timestamp $(date +%s) \
  '{
  version: {
    timestamp: $timestamp
  }
}' >&3
